#stop_sign - A
#current_index - B
#maximum_index - C
#free_variable_for_various_usage - E

if [0] < 2 then halt #V PŘÍPADĚ, ŽE BY POSLOUPNOST MĚLA JENOM JEDEN PRVEK, TAK BY MŮJ KOD VYHODIL CHYBU, 
                     #PROTO ZDE PROGRAM IHNED UKONČUJI, JELIKOŽ JEDNOPRVKOVÁ POSLOUPONOST JE STEJNĚ JIŽ SEŘAZENÁ

#DEKLARACE PROMĚNNÝCH
A := [0] #PROMĚNNÁ KTERÁ URČUJE KDE KONČÍ NESEŘAZENÁ ČÍSLA
B := 1 #PROMĚNNÁ KTERÁ UKLÁDÁ NA JAKÉ POZICI PŘI PROCHÁZENÍ ČÍSEL PRÁVĚ JSME
C := 1 #PROMĚNNÁ KTERÁ UKLÁDÁ POZICI MAXIMA V NESEŘAZENÝCH ČÍSLECH - NA ZAČÁTEK ZDE ULOŽÍME PRVNÍ ČÍSLO POSLOUPNOSTI
#----------------------
find_maximum_start: #ZAČÁTEK CYKLU NA NALEZENÍ MAXIMA V NESEŘAZENÝCH ČÍSLECH
B := B + 1 #ZVĚTŠENÍ SOUČASNÉHO INDEXU, ABYCHOM MOHLI ZPRACOVAT DALŠÍ ČÍSLO
if A < B then goto maximum_found #PODMÍNKA KONTROLUJÍCÍ ZDA JSME NEPŘESÁHLI HRANICI NESEŘAZENÝCH ČÍSEL
if [B] <= [C] then goto find_maximum_start #POKUD JE SOUČASNÉ ČÍSLO MENŠÍ JAK MAXIMUM, MŮŽEME POKRAČOVAT V HLEDÁNÍ DÁLE
C := B #ZDE SE UKLÁDÁ POZICE NOVÉHO MAXIMA - TATO SITUACE JE V PODSTATĚ ELSE VĚTŠÍ PODMÍNKY NA ŘÁDCE 15
goto find_maximum_start #VRACENÍ SE NA ZAČÁTEK CYKLU

maximum_found: #VĚTEV, KTERÁ PROHODÍ DVĚ ČÍSLA V PŘÍPADĚ, ŽE JSME JIŽ NALEZLI MAXIMUM
#PROHOZENÍ MAXIMA A POSLEDNÍHO PRVKU V NESEŘAZENÉ ČÁSTI ČÍSEL
E := [A] 
[A] := [C]
[C] := E
#------------------------------------------------------------------------------------
A := A - 1 #SNÍŽÍME HRANICI NESEŘAZENÝCH ČÍSEL O 1, JELIKOŽ JSME JIŽ ZAHRNULI NOVÉ MAXIMUM
if A = 1 then halt #POKUD JE HRANICE 1, TAK JSME JIŽ VŠE SEŘADILI A MŮŽEME PROGRAM UKONČIT
B := 1 #RESET - SOUČASNÝ INDEX NASTAVÍME NA 1, ABYCHOM MOHLI POKRAČOVAT V HLEDÁNÍ DALŠÍHO MAXIMA
C := 1 #DO MAXIMA ULOŽÍME PRVNÍ ČÍSLO POSLOUPNOSTI
goto find_maximum_start